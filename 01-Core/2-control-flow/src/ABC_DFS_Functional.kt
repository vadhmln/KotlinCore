package control_flow
//Понимание задачи: Ваша задача - найти последовательность символов от ‘a’ до ‘z’ в многомерной строке.
//Вы можете двигаться вверх, вправо, вниз или влево. Все символы, которые не являются частью этой последовательности,
//должны быть заменены на ‘-’.
//Разработка стратегии: Ваша стратегия заключается в использовании поиска в глубину (DFS) для нахождения
// последовательности от ‘a’ до ‘z’. Вы начинаете с каждой позиции ‘a’ и продолжаете двигаться,
// пока не найдете полную последовательность или не исчерпаете все возможные пути.
fun main() {
    val input = Array(readln().toInt()) { readln().toCharArray().toTypedArray() } // Чтение ввода
    /* flatMapIndexed: преобразует каждый элемент исходного массива input в форму,
    * определенную в лямбда-функции, и затем объединяет все полученные коллекции в одну.
    * flatMapIndexed принимает два аргумента: индекс элемента и сам элемент - y это индекс, а элемент - это line.
    * mapIndexedNotNull: преобразует каждый элемент line в форму,
    * определенную в лямбда-функции, и удаляет все null значения.
    * mapIndexedNotNull принимает два аргумента: индекс элемента и сам элемент - это x, а элемент - это c.
    * if (c == 'a') y to x else null: проверяет, равен ли текущий символ c символу ‘a’.
    * Если это так, то оно возвращает пару координат (y, x). В противном случае оно возвращает null.
    * В результате, starts будет содержать список всех координат (y, x), где символ ‘a’ присутствует в исходном массиве input.*/
    val starts =
        input.flatMapIndexed { y, line -> line.mapIndexedNotNull { x, c -> if (c == 'a') y to x else null } } // Поиск всех позиций 'a'
    for ((y, x) in starts) { // Перебор всех позиций 'a'
        val (success, chain) = input.dfs('a', y, x) // Запуск DFS из каждой позиции 'a'
        if (success) return input.solve(chain) // Если найдена полная последовательность, заменяем все остальные символы на '-'
    }
}

fun Array<Array<Char>>.dfs(c: Char, y: Int, x: Int): Pair<Boolean, List<Pair<Int, Int>>> { // Функция DFS
    if (c == 'z') return true to listOf(y to x) // Если текущий символ 'z', возвращаем true
    listOf(0 to 1, 0 to -1, 1 to 0, -1 to 0).forEach { (dy, dx) -> // Перебор всех возможных направлений движения
        if (y + dy in indices && x + dx in indices && this[y + dy][x + dx] == c + 1) { // Если следующая ячейка допустима
            val res = dfs(c + 1, y + dy, x + dx) // Запуск DFS из следующей ячейки
            if (res.first) return@dfs true to listOf(y to x) + res.second // Если DFS возвращает true, возвращаем true и текущую позицию вместе с остальной цепочкой
        }
    }
    return false to listOf() // Если не можем найти полную последовательность, возвращаем false
}

fun Array<Array<Char>>.solve(chain: List<Pair<Int, Int>>) { // Функция для замены всех символов, не входящих в цепочку, на '-'
    indices.forEach { a ->
        indices.forEach { b ->
            if (a to b !in chain) this[a][b] = '-' // Если текущая позиция не в цепочке, заменяем символ на '-'
        }
    }
    println(joinToString("\n") { it.joinToString("") }) // Выводим итоговую сетку
}
